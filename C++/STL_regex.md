C++ 标准库中的 `<regex>` 头文件提供了正则表达式的功能，允许开发者使用一种非常灵活的方式来搜索、替换或分割字符串。正则表达式是一种强大的文本处理工具，广泛应用于==数据验证==、文本分析和模式匹配等领域。

在 C++11 的 `<regex>` 中使用正则表达式时，需要在字符串字面量中对反斜杠 \ 进行转义，也就是写成双反斜杠 `\\`。

**为什么要双反斜杠？**
C++ 编译器会先处理字符串字面量的转义字符，而正则表达式引擎是后处理的。
例如你写 \d+，编译器会把 \d 视为未知转义字符报错或变成 d，正确写法 `\\d+`，编译器先把 `\\` 转为 \，正则引擎再读到 \d。
C++11 也支持 原始字符串（raw string），可以避免双反斜杠，非常适合写复杂正则：

regex re(R"(\d+)");         // 原始字符串，不需要写 `\\d`
- R"(...)" 里面内容不会做转义处理
- 建议在写多层 \ 的复杂正则时使用

在正则表达式中，有些字符具有特殊意义，被称为元字符
![[Pasted image 20251016105214.png|500]]

除此之外的其他字符则被称为字面字符。

例子1：
    `// 定义模板`
    `regex pattern(R"((\w+)(\.?\w+)*@(\w+)(\.\w+)+)");`


括号 `( … )`  
把里面当成**一个整体捕获组**，后面可以接量词（`*` `+` `?` 等），也可以单独提取。

`\w`  
等价于字符类 `[A-Za-z0-9_]`——**字母、数字、下划线** 中的任意一个。

`+`  
量词：前面那一项**连续出现 1 次或多次**（至少 1 个，不设上限）。

合起来 `\w+` 就是  
“**一口气连续拿下至少 1 个字母/数字/下划线**”，常用来匹配


`\.?`
- `\.` → 字面量“点号”（因为 `.` 在正则里本来代表“任意字符”，前面加 `\` 让它失去特殊含义，变成普通小数点）。    
- `?` → 量词“0 次或 1 次”，即**点号可有可无**。

`\w+`
- `\w` → 字母、数字、下划线 `[A-Za-z0-9_]`。
- `+` → 至少 1 个。

|量词|最少|最多|口诀|
|:--|:--|:--|:--|
|`*`|0 次|∞ 次|**可有可无，可重复**|
|`+`|1 次|∞ 次|**至少一次，可重复**|

---
`std::regex_match` 是 C++ 标准库 `<regex>` 里的**全串匹配**函数：
- 只有**整个字符串完全符合正则**时才返回 `true`；
- 只要开头或结尾多出一个无关字符就判失败。

函数原型（常用重载）
```cpp
bool regex_match(const std::string&  s,
                 const std::regex&  pattern);
bool regex_match(const std::string&  s,
                 std::smatch&       results,
                 const std::regex&  pattern);
```
- 第 1 个版本：纯判断，返回布尔。
- 第 2 个版本：顺便把捕获组结果写进 `std::smatch`（类似 `vector<string>`）供后续使用。