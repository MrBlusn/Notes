
## 1. 引言

“常量容器”并不是一种新的容器类型，而是**把容器本身声明为 `const`**——**容器一旦建成，长度、元素值都不能再改**，就像给整个盒子贴了封条。

| 写法                    | 能否增删元素 | 能否改元素值 | 能否读元素 |
| :-------------------- | :----- | :----- | :---- |
| `vector<int> v`       | ✅      | ✅      | ✅     |
| `const vector<int> v` | ❌      | ❌      | ✅     |

迭代器是一种特殊的对象，它能够遍历并指向容器中的元素。在C++中，迭代器的设计模拟了指针的行为（Pointers in C++），使得程序员能够通过它们访问和操作数据。

## 2. 标准容器的迭代器 (Iterators in Standard Containers)
### 2.1 `begin()` 和 `end()` 的使用

每一个标准容器，如 `vector`, `list`, `map` 等，都提供了 `begin()` 和 `end()` 方法来获取迭代器。`begin()` 返回指向容器第一个元素的迭代器，而 `end()` 返回指向容器最后一个元素之后的位置。这两个方法是我们在使用范围基于的 for 循环或者其他算法时的基石。
例如：
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for(auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    return 0;
}
```

在这个示例中，`begin()` 和 `end()` 返回的是 `iterator` 类型（迭代器类型），允许我们修改元素的值。


### 2.2 `cbegin()` 和 `cend()` 的引入和作用

为了提供更多的灵活性和安全性，C++ 标准库还提供了 `cbegin()` 和 `cend()` 方法。这两个方法无论容器是否为常量，总是返回 `const_iterator` 类型。
这里是一个使用 `cbegin()` 和 `cend()` 的例子：
```cpp
#include <vector>
#include <iostream>

int main() {
    const std::vector<int> vec = {1, 2, 3, 4, 5};
    for(auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    return 0;
}
```

在这个示例中，`cbegin()` 和 `cend()` 返回 `const_iterator` 类型，因此元素的值不能被修改。



`cbegin()` 就是 **“const 版 begin()”**——  它专门给你一张“**只读书签**”，从拿到手的那一刻起，编译器就禁止你通过这张书签去修改书页里的内容。

|调用|返回类型|能否修改元素|
|:--|:--|:--|
|`v.begin()`|`iterator`|✅ 可读可写|
|`v.cbegin()`|`const_iterator`|❌ 只能读|
### 2.3 常量和非常量容器中迭代器的表现

对于常量容器，`begin()` 和 `end()` 也会返回 `const_iterator` 类型。这是因为在常量容器上，我们不能修改其元素的值，这与 `cbegin()` 和 `cend()` 的行为一致。

然而，在非常量容器上，使用 `const auto&` 在范围基于的 for 循环中不会改变 `begin()` 和 `end()` 的返回类型。它们仍然返回 `iterator` 类型，但是元素的引用是常量。

## 3. 自定义容器和迭代器 (Custom Containers and Iterators)

### 示例代码

```cpp
template <typename T>
class MyContainer {
public:
    // 返回开始迭代器
    iterator begin() { return data_; }

    // 返回常量开始迭代器
    const_iterator begin() const { return data_; }

    // 返回结束迭代器
    iterator end() { return data_ + size_; }

    // 返回常量结束迭代器
    const_iterator end() const { return data_ + size_; }

private:
    T* data_;
    size_t size_;
};
```

在这个示例中，我们定义了一个简单的自定义容器。对于非常量容器，`begin()` 和 `end()` 返回 `iterator` 类型；对于常量容器，它们返回 `const_iterator` 类型。


### 3.2 cbegin() 和 cend() 在自定义容器中的实现

在自定义容器中实现 `cbegin()` 和 `cend()` 同样是一个好的实践。

### 示例代码

```cpp
template <typename T>
class MyContainer {
public:
    // ... 其他代码

    // 返回常量开始迭代器
    const_iterator cbegin() const { return data_; }

    // 返回常量结束迭代器
    const_iterator cend() const { return data_ + size_; }
};
```

在这个示例中，`cbegin()` 和 `cend()` 始终返回 `const_iterator` 类型，确保容器的元素不会被修改。

