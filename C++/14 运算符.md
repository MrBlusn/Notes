### 算数运算符
用于执行基本的数学计算。

| 运算符  | 描述        | 示例           |
| ---- | --------- | ------------ |
| `+`  | 加法        | `a + b`      |
| `-`  | 减法        | `a - b`      |
| `*`  | 乘法        | `a * b`      |
| `/`  | 除法        | `a / b`      |
| `%`  | 取模（求余数）   | `a % b`      |
| `++` | 自增（前缀/后缀） | `++a`, `a++` |
| `--` | 自减（前缀/后缀） | `--a`, `a--` |

### 关系运算符
用于比较两个值之间的关系，返回布尔值（`true` 或 `false`）。

|   |   |   |
|---|---|---|
|运算符|描述|示例|
|`==`|等于|`a == b`|
|`!=`|不等于|`a != b`|
|`>`|大于|`a > b`|
|`<`|小于|`a < b`|
|`>=`|大于或等于|`a >= b`|
|`<=`|小于或等于|`a <= b`|**

### 逻辑运算符
用于组合或反转布尔表达式，返回布尔值。

|   |   |   |
|---|---|---|
|运算符|描述|示例|
|`&&`|逻辑与（AND）|`a && b`|
|`||`|
|`!`|逻辑非（NOT）|`!a`|

### 位运算符

用于按位操作==整数==类型的==二进制==位。

|      |             |          |
| ---- | ----------- | -------- |
| 运算符  | 描述          | 示例       |
| `&`  | 按位与         | `a & b`  |
| `    | `           | 按位或      |
| `^`  | 按位异或（不等时为1） | `a ^ b`  |
| `~`  | 按位取反        | `~a`     |
| `<<` | 左移          | `a << 2` |
| `>>` | 右移          | `a >> 2` |
参加运算的两个数据，按**二进制位**进行==“与”==运算。  
运算规则：0&0=0; 0&1=0; 1&0=0; 1&1=1;  
即：**两位同时为“1”，结果才为“1”，否则为0**

**注意：负数按补码形式参加按位与运算。**
例如： -3 & 5  
　　　即 1111 1101 & 0000 0101 = 0000 0101  
　　　因此，-3 & 5的值得5

“与运算”的小技巧：

清零。若想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与， 结果为零。
例：3 & 0 = 0
取一个数的指定位。指定位置为1，其余为0。
例：设 X = 10101110，
　　取X的低4位： X & 0000 1111 = 0000 1110
　　取X的第5位： X & 0000 1000 = 0000 1000
判断奇偶
根据未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if (a & 1 == 0)代替if (a % 2 == 0)来判断a是不是偶数。


参加运算的两个数据，按二进制位进行“==异或==”运算。  
运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0；  
即：**参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。**

“异或运算”的小技巧：
（1）使特定位翻转 找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。
例：X=10101110，使X低4位翻转，用X ^ 0000 1111 = 1010 0001即可得到。

（2）与0相异或，保留原值 ，X ^ 0000 0000 = 1010 1110。
从上面的例题可以清楚的看到这一点。

==按位异或 `^` 一句话：相同为 0，不同为 1。==
==三板斧记住它==
1. ==无进位加法：1^1=0，0^0=0，1^0=1，0^1=1。==
2. ==自反性：a^a=0；a^0=a。==
3. ==可逆：若 a^b=c，则 a^c=b，b^c=a。==




### 赋值运算符
用于向变量赋值。

|   |   |   |
|---|---|---|
|运算符|描述|示例|
|`=`|简单赋值|`a = b`|
|`+=`|加后赋值|`a += b`|
|`-=`|减后赋值|`a -= b`|
|`*=`|乘后赋值|`a *= b`|
|`/=`|除后赋值|`a /= b`|
|`%=`|取模后赋值|`a %= b`|
|`&=`|按位与后赋值|`a &= b`|
|`|=`|按位或后赋值|
|`^=`|按位异或后赋值|`a ^= b`|
|`<<=`|左移后赋值|`a <<= 2`|
|`>>=`|右移后赋值|`a >>= 2`|

### 复合赋值运算符

结合赋值与其他运算的运算符（如上表中所示的`+=`, `-=`, 等）。

###  条件运算符

用于基于条件选择值。

|   |   |   |
|---|---|---|
|运算符|描述|示例|
|`?:`|条件（三目）运算符|`a ? b : c`|
###  指针运算符

用于操作指针。

|   |   |   |
|---|---|---|
|运算符|描述|示例|
|`*`|间接访问（解引用）|`*ptr`|
|`&`|取地址|`&a`|
|`->`|成员访问（指向对象的指针）|`ptr->member`|
|`[]`|数组下标访问|`arr[2]`|


### 成员访问运算符

用于访问类或结构体的成员。

|       |                  |                 |
| ----- | ---------------- | --------------- |
| 运算符   | 描述               | 示例              |
| `.`   | 直接成员访问           | `object.member` |
| `->`  | 指向成员的指针访问        | `ptr->member`   |
| `::*` | 指向成员的指针（成员指针操作符） | `Class::*ptr`   |

### 其他运算符

|          |              |                       |
| -------- | ------------ | --------------------- |
| 运算符      | 描述           | 示例                    |
| `sizeof` | 返回变量或类型所占字节数 | `sizeof(int)`         |
| `?:`     | 条件（三目）运算符    | `a ? b : c`           |
| `,`      | 逗号运算符        | `a = (b, c)`          |
| `typeid` | 运行时类型信息运算符   | `typeid(a)`           |
| `new`    | 动态内存分配       | `int *ptr = new int;` |
| `delete` | 动态内存释放       | `delete ptr;`         |


## 运算符重载

**运算符重载（Operator Overloading）** 允许开发者为自定义类型（如类和结构体）定义或改变运算符的行为，使其表现得像内置类型一样。这提高了代码的可读性和可维护性。

### 运算符重载的规则

1. **可重载运算符**：几乎所有的运算符都可以被重载，但如 `::`, `?:`, `sizeof` 等运算符不能被重载。

2. **至少一个操作数必须是用户定义类型**：即至少有一个操作数是类、结构体或联合体类型。

3. **运算符重载不改变运算符的优先级、结合性和操作数数量**。

### 运算符重载的基本语法

运算符可以作为成员函数或友元函数进行重载。

**成员函数重载示例：**

```
class Complex {
public:
    double real, imag;
    
    Complex operator+(const Complex &c) {
        Complex temp;
        temp.real = real + c.real;
        temp.imag = imag + c.imag;
        return temp;
    }
};
```

  

**友元函数重载示例：**

```
class Complex {
public:
    double real, imag;
    
    friend Complex operator+(const Complex &c1, const Complex &c2);
};

Complex operator+(const Complex &c1, const Complex &c2) {
    Complex temp;
    temp.real = c1.real + c2.real;
    temp.imag = c1.imag + c2.imag;
    return temp;
}
```

