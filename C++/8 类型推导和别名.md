## 类型别名

类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。

有两种方法可用于定义类型别名。传统的方法是使用关键字==typedef==：
![[Pasted image 20251009161750.png]]

新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
![[Pasted image 20251009161841.png]]
这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。


## 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。
例如下面的声明语句用到了类型`pstring`，它实际上是类型`char＊`的别名：
![[Pasted image 20251009161926.png]]

上述两条声明语句的基本数据类型都是`const pstring`，和过去一样，`const`是对给定类型的修饰。

`pstring`实际上是指向char的指针，因此，`const pstring`就是指向`char`的常量指针，而非指向常量字符的指针。

## 复杂情况

const 贴左不贴右，先展别名再贴 const

1. `const char * p1;`  
    → 指向 **const char** 的指针  
    数据只读，指针可改。
    
2. `char * const p2;`  
    → **常量指针** 指向 char  
    指针不可改，数据可改。
    
3. `char const * p3;`  
    等价于 1 号（const 位置可互换）  
    → 指向 const char 的指针。
    
4. `const char * const p4;`  
    → **常量指针** 指向 **const char**  
    双不可改。
    
5. `char * const * p5;`  
    → 指向“__常量指针 char_ const_*”的指针  
    `*p5` 那只指针不能改，`**p5` 的字符可改，`p5` 本身可改。
    
6. `char ** const p6;`  
    → **常量指针**，指向“指向 char 的指针”  
    `p6` 不可改，`*p6` 和 `**p6` 都可改。
    
7. `const char ** p7;`  
    → 指向“指向 **const char** 的指针”的指针  
    `**p7` 只读，`*p7` 和 `p7` 本身可改。
    
8. `char * const * const p8;`  
    → **常量指针**，指向“__常量指针 char_ const_*”  
    `p8` 不可改，`*p8` 不可改，`**p8` 可改。
    
9. `typedef char * P; const P p9;`  
    别名整体被 const → `char * const p9`  
    同 2 号：常量指针。
    
10. `typedef char * P; P const p10;`  
    与 9 完全等价，const 位置不影响结果 → `char * const p10`
    
11. `typedef const char * CP; CP * p11;`  
    先展开：`(const char *) * p11`  
    → 指向“指向 **const char** 的指针”的指针  
    同 7 号类型。
    
12. `using P = char *; const P p12;`  
    using 别名规则与 typedef 完全相同 → `char * const p12`  
    再次复习“别名整体被 const”。


## auto类型说明符

编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。

然而要做到这一点并非那么容易，有时甚至根本做不到。

为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。

和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：
![[Pasted image 20251009171931.png]]
使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：
![[Pasted image 20251009171957.png]]

`decltype` 是 C++11 引入的“类型查询”关键字，**编译期**把**任意表达式**的类型“原封不动”地取出来，不会触发求值。

三条核心规则

1. `decltype(e)`  
    若 `e` 是**未加括号**的**变量名/类成员访问**，则得到该实体**声明时的类型**（保留 cv-限定、引用）。
    
2. `decltype((e))` // 多一对括号  
    永远得到**值类别对应的引用类型**：
    
    - 左值 → `T&`
        
    - 将亡值 → `T&&`
        
    - 纯右值 → `T`
        
3. 表达式带逗号，只看**最右边**子表达式。

![[Pasted image 20251009195300.png]]
