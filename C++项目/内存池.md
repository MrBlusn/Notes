版本 v1 内存池，分三个文件，MemoryPool.h，MemoryPool.cpp，UnitTest.cpp

高效分配 / 释放小块内存（≤512 字节），避免原生`new/delete`的性能开销和内存碎片，大内存则回退到原生内存管理。
## MemoryPool.h

`#pragma once`
 作用：替代传统的`#ifndef/#define/#endif`==头文件保护机制==，确保当前头文件在一个编译单元中只被包含一次，防止重复定义错误（编译器原生支持，兼容性较好）。


`#define MEMORY_POOL_NUM 64`
`#define SLOT_BASE_SIZE 8` 
`#define MAX_SLOT_SIZE 512`
三个核心宏是内存池的配置基石，含义如下：
1. `MEMORY_POOL_NUM 64`：哈希桶中管理的**内存池数量为 64 个**（对应槽位大小从 8 字节到 512 字节，刚好 64 个等级）。
2. `SLOT_BASE_SIZE 8`：槽位的**基础单位大小为 8 字节**，所有内存池的槽位大小都是 8 的整数倍（内存对齐，提升访问效率，避免未对齐访问的性能损耗或硬件错误）。
3. `MAX_SLOT_SIZE 512`：内存池支持分配的**最大单块内存大小为 512 字节**，超过该大小的内存分配，直接使用原生`operator new`（内存池对大块内存优化效果差，回退原生更高效）。


```cpp
/* 具体内存池的槽大小没法确定，因为每个内存池的槽大小不同(8的倍数)
   所以这个槽结构体的sizeof 不是实际的槽大小 */
struct Slot 
{
    std::atomic<Slot*> next; // 原子指针
};
```
#### 详细解析
1. 注释说明：`Slot`结构体的大小（`sizeof(Slot)`）不等于实际分配给用户的槽位大小，它只是一个 **"链表节点标识"**—— 实际槽位大小由对应`MemoryPool`的`SlotSize_`决定（比如某内存池槽位大小为 16 字节，那么`Slot`结构体只占用前 8 字节（指针大小，64 位系统下），后 8 字节为用户可用内存）。
2. 成员变量`std::atomic<Slot*> next`：
 - 类型：==原子指针==，指向链表下一个`Slot`节点。
 - 作用：将空闲槽位组织成**无锁单向链表**（`freeList_`），`next`的原子操作（CAS）保证多线程下空闲链表的入队 / 出队线程安全，无需互斥锁，提升并发性能。