![[Pasted image 20260104093829.png|650]]
指令就是CPU能识别、执行的最基本命令，是二进制机器指令。
注：window等系统”小黑框“中的各种命令，其实是”交互式命令接口“，但很多人习惯把他称为指令，注意区分。

### 内核程序 VS 应用程序

| 对比维度      | 内核程序（Kernel Program）           | 应用程序（Application Program）  |
| --------- | ------------------------------ | -------------------------- |
| **定义**    | 操作系统内核的组成部分，是系统的核心底层程序         | 为满足用户特定需求而开发的上层程序          |
| **运行状态**  | 全程运行在**内核态**（特权态）              | 通常运行在**用户态**（非特权态）         |
| **权限级别**  | 最高权限，可直接访问所有硬件资源和执行特权指令        | 低权限，无法直接访问硬件，需通过系统调用请求内核协助 |
| **核心功能**  | 管理系统资源、实现进程调度、处理中断与异常、提供系统调用接口 | 满足用户具体需求，如办公、娱乐、编程等        |
| **稳定性要求** | 极高，内核程序崩溃会导致整个系统死机             | 较低，单个应用程序崩溃通常不影响系统其他部分     |
| **开发难度**  | 高，需深入理解硬件原理和操作系统底层机制           | 相对较低，可基于操作系统提供的 API 进行开发   |
| **典型示例**  | 进程调度器、内存管理模块、设备驱动程序            | 浏览器、Word、微信、游戏、编程软件        |
由很多内核程序组成操作系统的”操作系统内核“，简称”内核“。
内核是操作系统最重要最核心的部分，也是最接近硬件的部分。甚至可以说，一个操作系统只要有内核就够了。（eg. docker -> 仅需Linux内核）
操作系统的功能未必都在内核中，如图形界面GUI。

### 特权指令 VS 非特权指令

| 对比维度     | 特权指令（Privileged Instruction） | 非特权指令（Non-privileged Instruction） |
| -------- | ---------------------------- | --------------------------------- |
| **定义**   | 涉及系统资源控制、硬件操作的高权限指令          | 仅涉及程序自身数据处理的低权限指令                 |
| **操作对象** | 系统硬件、内核数据结构、全局资源             | 程序自身的内存、寄存器、局部变量                  |
| **执行后果** | 直接影响系统稳定性和安全性                | 仅影响当前程序，不会破坏系统                    |
| **典型示例** | 内存地址映射、中断屏蔽、I/O 操作、修改程序状态字   | 算术运算、逻辑运算、赋值、函数调用                 |
特权指令是操作系统内核实现资源管理和硬件控制的关键，直接操作系统核心资源，错误执行会导致系统崩溃或安全问题，因此==仅允许内核程序==使用。


CPU自生产出来后，就可以区分特权指令和非特权指令。一般只有内核程序可以执行特权指令。那么CPU怎么知道是内核程序还是应用程序在执行指令呢，引入内核态和用户态。

### 内核态 VS 用户态

别名，内核态：管态； 用户态：目态。

CPU有两种状态，内核态和用户态。
处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令；用户态同理。

CPU 通过**程序状态字（Program Status Word, PSW）** 中的**特权级标志位**来识别当前执行的程序是内核程序还是应用程序，进而判断是否允许执行特权指令。这一机制是实现内核态与用户态隔离、保障系统安全的核心。

PSW 是 CPU 中的一个专用寄存器，用于存储当前 CPU 的执行状态和关键标志，其中最核心的就是**特权级标志位**（也称为 “模式位”）。
- 当特权位为**0**时，CPU 处于**内核态**（特权态），此时认为当前执行的是内核程序，允许执行所有指令（包括特权指令和非特权指令）。
- 当特权位为**1**时，CPU 处于**用户态**（非特权态），此时认为当前执行的是应用程序，仅允许执行非特权指令。


CPU 在执行每一条指令前，会自动完成以下检查流程：
1. 读取 PSW 中的特权级标志位，确定当前执行状态（内核态 / 用户态）。
2. 判断即将执行的指令类型（特权指令 / 非特权指令）。
3. 匹配权限：
    - 若当前是内核态：直接执行所有指令，无权限限制。
    - 若当前是用户态：
        - 若为非特权指令：正常执行。
        - 若为特权指令：立即触发**非法指令异常**，CPU 暂停当前程序，切换到内核态执行异常处理程序（通常会终止该应用程序）。

### 程序状态的切换机制

CPU 的执行状态（内核态 / 用户态）并非固定不变，而是通过特定的**触发事件**和**指令**进行切换，确保应用程序在需要时能合法地请求内核服务。

#### 1. 用户态 → 内核态（权限提升）

这种切换是==被动==触发的，通常由以下三种事件引起：

- **系统调用**：应用程序需要访问硬件或执行特权操作时，通过执行`int`（中断）或`syscall`等指令主动向内核发起请求，触发状态切换。例如，C 语言中的`printf()`函数最终会通过系统调用`write()`向内核请求输出数据。
- **中断**：外部设备（如键盘、硬盘）完成操作后，向 CPU 发送中断信号，CPU 暂停当前用户程序，切换到内核态执行中断服务程序。
- **异常**：CPU 执行用户程序时检测到错误（如除数为零、内存访问越界），触发异常，切换到内核态执行异常处理程序。

#### 2. 内核态 → 用户态（权限降低）

这种切换是==主动==触发的，由内核程序执行特定指令完成：

- 内核完成系统调用、中断或异常的处理后，会执行`iret`（中断返回）或`sysret`等指令，恢复之前保存的用户程序上下文（包括 PSW 中的特权位），将 CPU 状态从内核态切换回用户态，继续执行应用程序。

![[Pasted image 20260104104109.png|700]]

![[Pasted image 20260104104139.png|700]]
